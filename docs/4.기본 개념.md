# 기본 개념

## 목차
1. [컴포넌트](#컴포넌트)
2. [JSX](#jsx)
3. [Props](#props)
4. [State](#state)
5. [라이프사이클 메서드](#라이프사이클-메서드)
6. [이벤트 처리](#이벤트-처리)

## 컴포넌트
컴포넌트는 React 애플리케이션의 기본 단위입니다. UI를 작은 조각으로 나누고 각 조각을 독립적으로 관리할 수 있게 합니다. 컴포넌트는 함수형 컴포넌트로 정의할 수 있습니다:
```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
컴포넌트는 재사용 가능하고, 컴포넌트 내부에 다른 컴포넌트를 포함할 수 있습니다. 이는 애플리케이션을 모듈화하고 유지보수를 용이하게 합니다.

## JSX
JSX는 JavaScript XML의 약자로, JavaScript 안에서 HTML을 작성할 수 있게 해주는 문법입니다. JSX를 사용하면 가독성이 좋아지고, UI를 정의하는 코드가 직관적이 됩니다:
```jsx
const element = <h1>Hello, world!</h1>;
```
JSX는 JavaScript로 변환되기 때문에, JSX 안에서 JavaScript 표현식을 사용할 수 있습니다:
```jsx
const name = 'Sara';
const element = <h1>Hello, {name}</h1>;
```

## Props
Props는 컴포넌트에 전달되는 데이터입니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용합니다. Props는 읽기 전용이며, 자식 컴포넌트에서 변경할 수 없습니다:
```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

function App() {
  return <Welcome name="Sara" />;
}
```
여기서 `name` prop이 `Welcome` 컴포넌트에 전달되고, `Welcome` 컴포넌트는 이를 사용하여 "Hello, Sara"를 렌더링합니다.

## State
State는 컴포넌트 내에서 관리되는 동적인 데이터입니다. 상태는 컴포넌트의 상태를 저장하고 변경할 수 있게 합니다. 함수형 컴포넌트에서는 `useState` 훅을 사용하여 상태를 관리할 수 있습니다:
```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Counter;
```
`useState`는 상태 변수를 선언하고, 이를 업데이트하는 함수(`setCount`)를 반환합니다. 상태가 변경되면 컴포넌트가 다시 렌더링됩니다.

## 라이프사이클 메서드
함수형 컴포넌트에서는 `useEffect` 훅을 사용하여 라이프사이클 메서드의 기능을 구현할 수 있습니다. `useEffect`는 컴포넌트가 마운트, 업데이트, 언마운트될 때 특정 작업을 수행할 수 있게 합니다:
```jsx
import React, { useState, useEffect } from 'react';

function Timer() {
  const [date, setDate] = useState(new Date());

  useEffect(() => {
    const timerID = setInterval(() => setDate(new Date()), 1000);
    
    // 컴포넌트가 언마운트될 때 타이머를 정리합니다.
    return () => clearInterval(timerID);
  }, []);

  return (
    <div>
      <h1>{date.toLocaleTimeString()}</h1>
    </div>
  );
}

export default Timer;
```
`useEffect`는 첫 번째 인수로 함수(효과)를 받습니다. 두 번째 인수로 빈 배열 `[]`을 전달하면, 이 효과는 컴포넌트가 마운트될 때 한 번만 실행됩니다. 반환된 함수는 컴포넌트가 언마운트될 때 실행됩니다.

## 이벤트 처리
React에서는 DOM 이벤트와 유사하게 이벤트 핸들러를 설정할 수 있지만, camelCase로 작성해야 합니다. 이벤트 핸들러는 함수를 정의하여 특정 이벤트가 발생할 때 해당 함수를 호출합니다.

### 예제: 버튼 클릭 이벤트 핸들러
```jsx
import React, { useState } from 'react';

function ClickButton() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={handleClick}>
        Click me
      </button>
    </div>
  );
}

export default ClickButton;
```

### 이벤트 객체 사용
이벤트 핸들러는 이벤트 객체를 매개변수로 받습니다. 이를 통해 이벤트에 대한 추가 정보를 얻을 수 있습니다.
```jsx
import React, { useState } from 'react';

function InputForm() {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event) => {
    setInputValue(event.target.value);
  };

  return (
    <div>
      <input type="text" value={inputValue} onChange={handleChange} />
      <p>Input value: {inputValue}</p>
    </div>
  );
}

export default InputForm;
```

### 기본 동작 방지와 이벤트 전파
이벤트의 기본 동작을 방지하거나 이벤트 전파를 막아야 할 경우, `event.preventDefault()`와 `event.stopPropagation()`을 적절히 사용합니다.
```jsx
function Link() {
  const handleClick = (event) => {
    event.preventDefault();
    console.log('Link was clicked, but default behavior is prevented.');
  };

  return (
    <a href="https://example.com" onClick={handleClick}>
      Click me
    </a>
  );
}

export default Link;
```

### 이벤트 핸들러 사용 시 주의사항
1. **이벤트 핸들러에 함수 전달**: `onClick` 속성에 직접 함수를 전달해야 합니다. 함수를 호출한 결과를 전달하면 안 됩니다.
   ```jsx
   <button onClick={handleClick}>Click me</button>  // 올바른 예
   <button onClick={handleClick()}>Click me</button>  // 잘못된 예
   ```

2. **함수 바인딩**: 클래스형 컴포넌트에서 이벤트 핸들러를 사용할 때는 `this` 바인딩을 주의해야 합니다.
   ```jsx
   class MyComponent extends React.Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 };
       this.handleClick = this.handleClick.bind(this);
     }

     handleClick() {
       this.setState({ count: this.state.count + 1 });
     }

     render() {
       return (
         <button onClick={this.handleClick}>
           Click me
         </button>
       );
     }
   }
   ```

3. **성능 고려**: 렌더링 시마다 새 함수를 생성하지 않도록 `useCallback` 훅을 사용하여 함수 참조를 캐시할 수 있습니다.
   ```jsx
   import React, { useState, useCallback } from 'react';

   function MyComponent() {
     const [count, setCount] = useState(0);

     const handleClick = useCallback(() => {
       setCount(prevCount => prevCount + 1);
     }, []);

     return (
       <button onClick={handleClick}>
         Click me
       </button>
     );
   }
   ```

4. **SyntheticEvent 객체의 수명**: 이벤트 핸들러 내에서 이벤트 객체를 비동기 코드에서 사용할 경우 이벤트 객체의 속성을 별도로 저장해야 합니다.
   ```jsx
   function MyComponent() {
     const handleClick = (event) => {
       event.persist();
       setTimeout(() => {
         console.log(event.target);
       }, 1000);
     };

     return (
       <button onClick={handleClick}>
         Click me
       </button>
     );
   }
   ```

이러한 주의 사항들을 염두에 두고 `onClick` 이벤트 핸들러를 사용하면, 더 안정적이고 성능이 좋은 React 애플리케이션을 개발할 수 있습니다.
